+++
title = "quips of cards and pokes"
weight = 2
template = "doc.html"
+++

This brief breakout lesson covers what cards and pokes are. This material will be more generally covered in other lessons but if you just can't wait for that, let's proceed:

## [cards](https://github.com/urbit/urbit/blob/0f069a08e83dd0bcb2eea2e91ed611f0074ecbf8/pkg/arvo/sys/lull.hoon#L1660)
A card is defined in lull.hoon as a `(wind note gift)`.  A [wind](https://github.com/urbit/urbit/blob/master/pkg/arvo/sys/arvo.hoon#L122) is a wet gate that takes two molds and produces a structure that is tagged by a head atom (a tuple with either `%pass`, `%slip`, or `%give` as the head, which then further deliniates the tail structure - see the link to arvo.hoon above). This type of structure with a head atom tag is also called a "tagged union".

Basically, winds are used to communicate between vanes, including messages from %gall to %gall (between agents) and so on. Vanes that need something from another vane request it by `%pass`ing a note. The produced result is `%give`n as a gift back to the requester.  All of this to say that, simply, a card is a means of intercommunication between agents and vanes.

A [quip](https://urbit.org/docs/reference/library/1c/#quip) is mold that takes two molds as arguments and produces a tuple of a list of the first mold argument and the mold of the second argument. A `(quip card _this)` produces, then, a list of cards and a mold of the type of our agent (`this` is defined in the alias section of all %gall agents as the whole core to which it refers - `+*  this  .`, and as a note `_noun` produces "the type of the noun", which is in our case `this`).

In other words, whenever you see an arm that has its output typed as a `(quip card _this)` (denoted by `^-  (quip card _this)`), that arm will result in the production of a list of cards (or instructions to agents or vanes) and a new version of `this` (or the agent itself) with a (potentially) changed state. In the `++  on-poke` arm, pokes do the work of creating the state change and initiating the list of cards, so let's take a look at pokes.

## pokes
A poke is just a one-time input to some %gall agent. pokes are handled by the `++  on-poke` arm of a %gall agent. `++  on-poke`returns a `(quip card _this)` and takes both a mark and a vase.

This mark vase cell is also called a [cage](https://github.com/urbit/urbit/blob/0f069a08e83dd0bcb2eea2e91ed611f0074ecbf8/pkg/arvo/sys/arvo.hoon#L45) which is, itself, defined as a (cask vase). cask (defined one line below cage, linked above) is a wet gate that takes a vase and creates a pair of a mark and the argument it receives (in this case, a vase). In the dojo, you can communicate a poke using the following format: `:app-name &mark [%type noun-of-that-type]`.

The handling of a noun poke entered through dojo is defined in the `++  on-poke` arm, as described. `+on-poke` takes a mark and a vase as its sample. You can then swithc the behavior of your agent based on the incoming (first) mark and (then) vase. Sometimes, agents will be written to take simple nouns, allowing your poke to read like `:simple-noun-agent noun`, but often times you will see apps taking vases of types defined in the /sur file for that app. Additionally, you'll see some apps have /mar files for the app. The /mar file is used to conform incoming pokes to the /sur file specification and handle converting non-noun pokes into interpretable types (that is, incoming JSON pokes, for instance, must be converted to nouns for the /app file to handle them).

The effects generated by an incoming poke come in the form of a quip of some (or no) cards and a changed state. In other words, a `(quip card _this)`!