---
navhome: /docs/
---


# 4j: parsing (bases and base digits)
### `++ab`

Primitive parser engine

A core containing numeric parser primitives.

Source
------

    ++  ab
      |%

Examples
--------

    > ab
    <36.ecc 414.gly 100.xkc 1.ypj %164>

------------------------------------------------------------------------

### `++bix`

Parse hex pair

Parsing `++rule`. Parses a pair of base-16 digits. Used in escapes.

Accepts
-------

XX

Produces
--------

A an atom. XX

Source
------

      ++  bix  (bass 16 (stun [2 2] six))

Examples
--------

    > (scan "07" bix:ab)
    q=7
    > (scan "51" bix:ab)
    q=81
    > (scan "a3" bix:ab)
    q=163

------------------------------------------------------------------------

### `++hif`

Parse phonetic pair

Parsing `++rule`. Parses an atom of odor `@pE`, a phrase of two bytes
encoded phonetically.

Accepts
-------

XX

Produces
--------

An atom.

Source
------

      ++  hif  (boss 256 ;~(plug tip tiq (easy ~)))

Examples
--------

    > (scan "doznec" hif:ab)
    q=256
    > (scan "pittyp" hif:ab)
    q=48.626

------------------------------------------------------------------------

### `++huf`

Parse two phonetic pairs

Parsing `++rule`. Parses and unscrambles an atom of odor @pF, a phrase
of two two-byte pairs that are encoded (and scrambled) phonetically.

Accepts
-------

XX

Produces
--------

An atom. XX

Source
------

      ++  huf  %+  cook
                   |=([a/@ b/@] (wred:un ~(zug mu ~(zag mu [a b]))))
                 ;~(plug hif ;~(pfix hep hif))

Examples
--------

    > (scan "pittyp-pittyp" huf:ab)
    328.203.557
    > (scan "tasfyn-partyv" huf:ab)
    65.792
    > `@ux`(scan "tasfyn-partyv" huf:ab)
    0x1.0100

------------------------------------------------------------------------

### `++hyf`

Parse 8 phonetic bytes

Parsing `++rule`. Parses an atom of odor @pG, a phrase of eight of
phonetic bytes.

Accepts
-------

An atom of odor `@pG`

Produces
--------

An atom. XX

Source
------

      ++  hyf  (bass 0x1.0000.0000 ;~(plug huf ;~(pfix hep huf) (easy ~)))

Examples
--------

    > (scan "sondel-forsut-tillyn-nillyt" hyf:ab)
    q=365.637.097.828.335.095
    > `@u`~sondel-forsut-tillyn-nillyt
    365.637.097.828.335.095

------------------------------------------------------------------------

### `++pev`

Parse \<= 5 base-32

Parsing `++rule`. Parses up to five base-32 digits without a leading zero.

Accepts
-------

Up to five @uv (base 64) digits.

Produces
--------

An atom.

Source
------

      ++  pev  (bass 32 ;~(plug sev (stun [0 4] siv)))

Examples
--------

    > (scan "a" pev:ab)
    q=10
    > (scan "290j" pev:ab)
    q=74.771
    > (scan "123456" pev:ab)
    ! {1 6}
    ! exit
    > (scan "090j" pev:ab)
    ~ <syntax error at [1 11]>

------------------------------------------------------------------------

### `++pew`

Parse \<= 5 base-64

Parsing `++rule`. Parses up to five base-64 digits without a leading zero.

Accepts
-------

Up to five @uw (base 64) digits.

Produces
--------



Source
------

      ++  pew  (bass 64 ;~(plug sew (stun [0 4] siw)))

Examples
--------

    > (scan "Q" pew:ab)
    q=52
    > (scan "aQ~9" pew:ab)
    q=2.838.473
    > `@`0waQ~9
    2.838.473
    > (scan "123456" pew:ab)
    ! {1 6}
    ! exit
    > (scan "012345" pew:ab)
    ! {1 1}
    ! exit

------------------------------------------------------------------------

### `++piv`

Parse 5 base-32

Parsing `++rule`. Parses exactly five base-32 digits.

Accepts
-------

Produces
--------

Source
------

      ++  piv  (bass 32 (stun [5 5] siv))

Examples
--------

    > (scan "10b3l" piv:ab)
    q=1.059.957
    > (scan "1" piv:ab)
    ! {1 2}
    ! exit

------------------------------------------------------------------------

### `++piw`

Parse 5 base-64

Parsing `++rule`. Parses exactly five base-64 digits.

Accepts
-------

Produces
--------

Source
------

      ++  piw  (bass 64 (stun [5 5] siw))

Examples
--------

    > (scan "2C-pZ" piw:ab)
    q=43.771.517
    > (scan "2" piv:ab)
    ! {1 2}
    ! exit

------------------------------------------------------------------------

### `++qeb`

Parse \<= 4 binary

Parsing `++rule`. Parses a binary number of up to 4 digits in length without
a leading zero.

Accepts
-------

Produces
--------

Source
------

      ++  qeb  (bass 2 ;~(plug seb (stun [0 3] sib)))

Examples
--------

    > (scan "1" qeb:ab)
    q=1
    > (scan "101" qeb:ab)
    q=5
    > (scan "1111" qeb:ab)
    q=15
    > (scan "11111" qeb:ab)
    ! {1 5}
    ! exit
    > (scan "01" qeb:ab)
    ! {1 1}
    ! exit

------------------------------------------------------------------------

### `++qex`

Parse \<= 4 hex

Parsing `++rule`. Parses a hexadecimal number of up to 4 digits in length
without a leading zero.

Accepts
-------

Produces
--------

Source
------

      ++  qex  (bass 16 ;~(plug sex (stun [0 3] hit)))

Examples
--------

    > (scan "ca" qex:ab)
    q=202
    > (scan "18ac" qex:ab)
    q=6.316
    > (scan "18acc" qex:ab)
    ! {1 5}
    ! exit
    > (scan "08ac" qex:ab)
    ! {1 1}
    ! exit

------------------------------------------------------------------------

### `++qib`

Parse 4 binary

Parsing `++rule`. Parses exactly four binary digits.

Accepts
-------

Produces
--------

Source
------

      ++  qib  (bass 2 (stun [4 4] sib))

Examples
--------

    > (scan "0001" qib:ab)
    q=1
    > (scan "0100" qib:ab)
    q=4
    > (scan "110" qib:ab)
    ! {1 4}
    ! exit

------------------------------------------------------------------------

### `++qix`

Parse 4 hex

Parsing `++rule`. Parses exactly four hexadecimal digits.

Accepts
-------

Produces
--------

Source
------

      ++  qix  (bass 16 (stun [4 4] six))

Examples
--------

    > (scan "0100" qix:ab)
    q=256
    > (scan "10ff" qix:ab)
    q=4.351
    > (scan "0" qix:ab)
    ! {1 2}
    ! exit

------------------------------------------------------------------------

### `++seb`

Parse 1

Parsing `++rule`. Parses the number 1.

Accepts
-------

Produces
--------

Source
------

      ++  seb  (cold 1 (just '1'))

Examples
--------

    > (scan "1" seb:ab)
    1
    > (scan "0" seb:ab)
    ! ~zod/try/~2014.10.23..22.34.21..bfdd/:<[1 1].[1 18]>
    ! {1 1}
    > (scan "2" seb:ab)
    ! ~zod/try/~2014.10.23..22.34.29..d399/:<[1 1].[1 18]>
    ! {1 1}

------------------------------------------------------------------------

### `++sed`

Parse decimal

Parsing `++rule`. Parses a nonzero decimal digit.

Accepts
-------

Produces
--------

Source
------

      ++  sed  (cook |=(a/@ (sub a '0')) (shim '1' '9'))

Examples
--------

    > (scan "5" sed:ab)
    5
    > (scan "0" sed:ab)
    ! {1 1}
    ! exit

------------------------------------------------------------------------

### `++sev`

Parse base-32

Parsing `++rule`. Parses a nonzero base-32 digit

Accepts
-------

Produces
--------

Source
------

      ++  sev  ;~(pose sed sov)

Examples
--------

    > (scan "c" sev:ab)
    12
    ~zod/socialnet=> (scan "0" sev:ab)
    ! {1 1}
    ! exit

------------------------------------------------------------------------

### `++sew`

Parse base-64

Parsing `++rule`. Parses a nonzero base-64 digit

Accepts
-------

Produces
--------

Source
------

      ++  sew  ;~(pose sed sow)

Examples
--------

    > (scan "M" sew:ab)
    48
    > (scan "0" sew:ab)
    ! {1 1}
    ! exit

------------------------------------------------------------------------

### `++sex`

Parse hex

Parsing `++rule`. Parses a nonzero hexadecimal digit.

Accepts
-------

Produces
--------

Source
------

      ++  sex  ;~(pose sed sox)

Examples
--------

    > (scan "e" sex:ab)
    14
    > (scan "0" sex:ab)
    ! {1 1}
    ! exit

------------------------------------------------------------------------

### `++sib`

Parse binary

Parsing `++rule`. Parses a binary digit.

Accepts
-------

Produces
--------

Source
------

      ++  sib  (cook |=(a/@ (sub a '0')) (shim '0' '1'))

Examples
--------

    > (scan "1" sib:ab)
    1
    ~zod/socialnet=> (scan "0" sib:ab)
    0

------------------------------------------------------------------------

### `++sid`

Parse decimal

Parsing `++rule`. Parses a decimal digit.

Accepts
-------

Produces
--------

Source
------

      ++  sid  (cook |=(a/@ (sub a '0')) (shim '0' '9'))

Examples
--------

    > (scan "5" sid:ab)
    5

------------------------------------------------------------------------

### `++siv`

Parse base-32

Parsing `++rule`. Parses a base-32 digit.

Accepts
-------

Produces
--------

Source
------

      ++  siv  ;~(pose sid sov)

Examples
--------

    > (scan "c" siv:ab)
    12

------------------------------------------------------------------------

### `++siw`

Parse base-64

Parsing `++rule`. Parses a base-64 digit.

Accepts
-------

Produces
--------

Source
------

      ++  siw  ;~(pose sid sow)

Examples
--------

    > (scan "M" siw:ab)
    48

------------------------------------------------------------------------

### `++six`

Parse hex

Parsing `++rule`. Parses a hexadecimal digit.

Accepts
-------

Produces
--------

Source
------

      ++  six  ;~(pose sid sox)

Examples
--------

    > (scan "e" six:ab)
    14

------------------------------------------------------------------------

### `++sov`

Parse base-32

Parsing `++rule`. Parses a base-32 letter.

Accepts
-------

Produces
--------

Source
------

      ++  sov  (cook |=(a/@ (sub a 87)) (shim 'a' 'v'))

Examples
--------

    > (scan "c" sov:ab)
    12

------------------------------------------------------------------------

### `++sow`

Parse base-64

Parsing `++rule`. Parses a base-64 letter/symbol.

Accepts
-------

Produces
--------

Source
------

      ++  sow  ;~  pose
                 (cook |=(a/@ (sub a 87)) (shim 'a' 'z'))
                 (cook |=(a/@ (sub a 29)) (shim 'A' 'Z'))
                 (cold 62 (just '-'))
                 (cold 63 (just '~'))
               ==

Examples
--------

    > (scan "M" sow:ab)
    48

------------------------------------------------------------------------

### `++sox`

Parse hex letter

Parsing `++rule`. Parses a hexadecimal letter.

Accepts
-------

Produces
--------

Source
------

      ++  sox  (cook |=(a/@ (sub a 87)) (shim 'a' 'f'))

Examples
--------

    > (scan "e" sox:ab)
    14

------------------------------------------------------------------------

### `++ted`

Parse \<= 3 decimal

Parsing `++rule`. Parses a decimal number of up to 3 digits without a
leading zero.

Accepts
-------

Produces
--------

Source
------

      ++  ted  (bass 10 ;~(plug sed (stun [0 2] sid)))

Examples
--------

    > (scan "21" ted:ab)
    q=21
    > (scan "214" ted:ab)
    q=214
    > (scan "2140" ted:ab)
    {1 4}
    > (scan "0" ted:ab)
    ! {1 1}
    ! exit

------------------------------------------------------------------------

### `++tip`

Leading phonetic byte

Parsing `++rule`. Parses the leading phonetic byte, which represents a
syllable.

Accepts
-------

Produces
--------

Source
------

      ++  tip  (sear |=(a/@ (ins:po a)) til)

Examples
--------

    > (scan "doz" tip:ab)
    0
    > (scan "pit" tip:ab)
    242

------------------------------------------------------------------------

### `++tiq`

Trailing phonetic syllable

Parsing `++rule`. Parses the trailing phonetic byte, which represents a
syllable.

Accepts
-------

Produces
--------

Source
------

      ++  tiq  (sear |=(a/@ (ind:po a)) til)

Examples
--------

    > (scan "zod" tiq:ab)
    0
    > (scan "nec" tiq:ab)
    1

------------------------------------------------------------------------

### `++tid`

Parse 3 decimal digits

Parsing `++rule`. Parses exactly three decimal digits.

Accepts
-------

Produces
--------

Source
------

      ++  tid  (bass 10 (stun [3 3] sid))

Examples
--------

    > (scan "013" tid:ab)
    q=13
    > (scan "01" tid:ab)
    ! {1 3}
    ! exit

------------------------------------------------------------------------

### `++til`

Parse 3 lowercase

Parsing `++rule`. Parses exactly three lowercase letters.

Accepts
-------

Produces
--------

Source
------

      ++  til  (boss 256 (stun [3 3] low))

Examples
--------

    > (scan "mer" til:ab)
    q=7.497.069
    > `@t`(scan "mer" til:ab)
    'mer'
    > (scan "me" til:ab)
    ! {1 3}
    ! exit

------------------------------------------------------------------------

### `++urs`

Parse span characters

Parsing rule. Parses characters from an atom of the span odor `@ta`.

Accepts
-------

Produces
--------

Source
------

      ++  urs  %+  cook
                 |=(a/tape (rap 3 ^-((list @) a)))
               (star ;~(pose nud low hep dot sig cab))

Examples
--------

    > `@ta`(scan "asa-lom_tak" urs:ab)
    ~.asa-lom_tak 
    > `@t`(scan "asa-lom_tak" urs:ab)
    'asa-lom_tak'

------------------------------------------------------------------------

### `++urt`

Parse non-`_` span

Parsing rule. Parses all characters of the span odor `@ta` except
for cab, `_`.

Accepts
-------

Produces
--------

Source
------

      ++  urt  %+  cook
                 |=(a/tape (rap 3 ^-((list @) a)))
               (star ;~(pose nud low hep dot sig))

Examples
--------

    > `@t`(scan "asa-lom.t0k" urt:ab)
    'asa-lom.t0k'

------------------------------------------------------------------------

### `++voy`

Parse bas, soq, or bix

Parsing rule. Parses an escaped backslash, single quote, or hex pair
byte.

Accepts
-------

Produces
--------

Source
------

      ++  voy  ;~(pfix bas ;~(pose bas soq bix))

Examples
--------

    > (scan "\\0a" voy:ab)
    q=10
    > (scan "\\'" voy:ab)
    q=39

------------------------------------------------------------------------

### `++ag`

Top-level atom parser engine

A core containing top-level atom parsers.

Accepts
-------

Produces
--------

Source
------

    ++  ag
      |%

Examples
--------

    > ag
    <14.vpu 414.mof 100.xkc 1.ypj %164>

------------------------------------------------------------------------

### `++ape`

Parse 0 or rule

Parser modifier. Parses 0 or the sample rule `fel`.

Accepts
-------

Produces
--------

`fel` is a `rule`.

Source
------

      ++  ape  |*(fel/rule ;~(pose (cold 0 (just '0')) fel))


Examples
--------

    > (scan "202" (star (ape:ag (cold 2 (just '2')))))
    ~[2 0 2]

------------------------------------------------------------------------

### `++bay`

Parses binary number

Parsing rule. Parses a binary number without a leading zero.

Accepts
-------

Produces
--------

Source
------

      ++  bay  (ape (bass 16 ;~(plug qeb:ab (star ;~(pfix dog qib:ab)))))

Examples
--------

    > (scan "10.0110" bay:ag)
    q=38

------------------------------------------------------------------------

### `++bip`

Parse IPv6

Parsing rule. Parses a `@is`, an IPv6 address.

Accepts
-------

Produces
--------

Source
------

      ++  bip  =+  tod=(ape qex:ab)
               (bass 0x1.0000 ;~(plug tod (stun [7 7] ;~(pfix dog tod))))

Examples
--------

    > (scan "0.0.ea.3e6c.0.0.0.0" bip:ag)
    q=283.183.420.760.121.105.516.068.864
    > `@is`(scan "0.0.ea.3e6c.0.0.0.0" bip:ag)
    .0.0.ea.3e6c.0.0.0.0

------------------------------------------------------------------------

### `++dem`

Parse decimal with dots

Parsing rule. Parses a decimal number that includes dot separators.

Accepts
-------

Produces
--------

Source
------

      ++  dem  (ape (bass 1.000 ;~(plug ted:ab (star ;~(pfix dog tid:ab)))))


Examples
--------

    > (scan "52" dem:ag)
    q=52
    > (scan "13.507" dem:ag)
    q=13.507

------------------------------------------------------------------------

### `++dim`

Parse decimal number

Parsing rule. Parses a decimal number without a leading zero.

Accepts
-------

Produces
--------

Source
------

      ++  dim  (ape (bass 10 ;~(plug sed:ab (star sid:ab))))

Examples
--------

    > (scan "52" dim:ag)
    q=52
    > (scan "013507" dim:ag)
    ! {1 2}
    ! exit

------------------------------------------------------------------------

### `++dum`

Parse decimal with leading `0`

Parsing rule. Parses a decmial number with leading zeroes.

Accepts
-------

Produces
--------

Source
------

      ++  dum  (bass 10 (plus sid:ab))

Examples
--------

    > (scan "52" dum:ag)
    q=52
    > (scan "0000052" dum:ag)
    q=52
    > (scan "13507" dim:ag)
    q=13.507

------------------------------------------------------------------------

### `++fed`

Parse phonetic base

Parsing rule. Parses an atom of odor `@p`, the phonetic base.

Accepts
-------

Produces
--------

Source
------

      ++  fed  ;~  pose
                 (bass 0x1.0000.0000.0000.0000 (most doh hyf:ab))
                 huf:ab
                 hif:ab
                 tiq:ab
               ==

Examples
--------

    > (scan "zod" fed:ag)
    0
    > (scan "nec" fed:ag)
    1
    > (scan "sondel" fed:ag)
    9.636
    > ~tillyn-nillyt
    ~tillyn-nillyt
    > (scan "tillyn-nillyt" fed:ag)
    3.569.565.175
    > (scan "tillyn-nillyt-tasfyn-partyv" fed:ag)
    15.331.165.687.565.582.592
    > (scan "tillyn-nillyt-tasfyn-partyv--novweb-talrud-talmud-sonfyr" fed:ag)
    282.810.089.790.159.633.869.501.053.313.363.681.181

------------------------------------------------------------------------

### `++hex`

Parse hex

Parsing rule. Parses a hexadecimal number

Accepts
-------

Produces
--------

Source
------

      ++  hex  (ape (bass 0x1.0000 ;~(plug qex:ab (star ;~(pfix dog qix:ab)))))

Examples
--------

    > (scan "4" hex:ag)
    q=4
    > (scan "1a" hex:ag)
    q=26
    > (scan "3.ac8d" hex:ag)
    q=240.781
    > `@ux`(scan "3.ac8d" hex:ag)
    0x3.ac8d

------------------------------------------------------------------------

### `++lip`

Parse IPv4 address

Parsing rule. Parses an IPv4 address.

Accepts
-------

Produces
--------

Source
------

      ++  lip  =+  tod=(ape ted:ab)
               (bass 256 ;~(plug tod (stun [3 3] ;~(pfix dog tod))))

Examples
--------

    > (scan "127.0.0.1" lip:ag)
    q=2.130.706.433
    > `@if`(scan "127.0.0.1" lip:ag)
    .127.0.0.1
    > `@if`(scan "8.8.8.8" lip:ag)
    .8.8.8.8

------------------------------------------------------------------------

### `++viz`

Parse Base-32 with dots

Parsing rule. Parses a Base-32 number with dot separators.

Accepts
-------

Produces
--------

Source
------

      ++  viz  (ape (bass 0x200.0000 ;~(plug pev:ab (star ;~(pfix dog piv:ab)))))

Examples
--------

    > (scan "e2.ol4pm" viz:ag)
    q=15.125.353.270

------------------------------------------------------------------------

### `++vum`

Parse base-32 string

Parsing rule. Parses a raw base-32 string.

Accepts
-------

Produces
--------

Source
------

      ++  vum  (bass 32 (plus siv:ab))

Examples
--------

    > (scan "e2ol4pm" vum:ag)
    q=15.125.353.270

------------------------------------------------------------------------

### `++wiz`

Parse base-64

Parsing rule. Parses a base-64 number.

Accepts
-------

Produces
--------

Source
------

      ++  wiz  (ape (bass 0x4000.0000 ;~(plug pew:ab (star ;~(pfix dog piw:ab)))))
      --
    ::

Examples
--------

    > (scan "e2O.l4Xpm" wiz:ag)
    q=61.764.130.813.526

***
### `++mu`

Core used to scramble 16-bit atoms

A door that contains arms that are used to scramble two atoms, `top`
and `bot`. Used especially in the phonetic base to disguise the
relationship between a destroyer and its cruiser.

Accepts
-------

Produces
--------

`bot` is an atom.

`top` is an atom.

Source
------

    ++  mu
      |_  [top/@ bot/@]

Examples
--------

    > ~(. mu 0x20e5 0x5901)
    <3.sjm [[@ux @ux] <414.hhh 100.xkc 1.ypj %164>]>

------------------------------------------------------------------------

### `++zag`

Add bottom into top

Produces the cell of `top` and `bot` with `top` scrambled to the result
of adding `bot` to `top` modulo 16. Used to scramble the name of a
destroyer.

Accepts
-------

Produces
--------

`bot` is an atom.

`top` is an atom.

Source
------

      ++  zag  [p=(end 4 1 (add top bot)) q=bot]


Examples
--------

    > `[@ux @ux]`~(zag mu 0x20e0 0x201)
    [0x22e1 0x201]

------------------------------------------------------------------------

### `++zig`

Subtract bottom from top

The inverse of `++zag`. Produces the cell of `top` and `bot` with
`top` unscrambled. The unscrambled `top` is the sum of the sample `top`
and the 16-bit complement of `bot`. Used to unscramble the name of the
destroyer.

Accepts
-------

Produces
--------

`bot` is an atom.

`top` is an atom.

Source
------

      ++  zig  [p=(end 4 1 (add top (sub 0x1.0000 bot))) q=bot]

Examples
--------

    > `[@ux @ux]`~(zig mu 0x2f46 0x1042)
    [0x1f04 0x1042]

------------------------------------------------------------------------

### `++zug`

Concatenate into atom

Produces the concatenation of `top` and `bot`. Used to assemble a
destroyer name.

Accepts
-------

Produces
--------

`bot` is an atom.

`top` is an atom.

Source
------

      ++  zug  (mix (lsh 4 1 top) bot)

Examples
--------

    > `@ux`~(zug mu 0x10e1 0xfa)
    0x10e1.00fa



***
### `++ne`

Digit rendering engine

A door containing arms that render digits at bases 10, 16, 32, and
64.

Accepts
-------

Produces
--------

`tig` is an `atom`.

Source
------

    ++  ne
      |_  tig/@

Examples
--------

    > ~(. ne 20)
    <4.gut [@ud <414.hhh 100.xkc 1.ypj %164>]>

------------------------------------------------------------------------

### `++d`

Render decimal

Renders a decimal digit as an atom of an ACII byte value.

Accepts
-------

Produces
--------

`tig` is an `atom`.

Source
------

      ++  d  (add tig '0')

Examples
--------

    > `@t`~(d ne 7)
    '7'

------------------------------------------------------------------------

### `++x`

Render hex

Renders a hexadecimal digit as an atom of an ASCII byte value.

Accepts
-------

Produces
--------

`tig` is an `atom`.

Source
------

      ++  x  ?:((gte tig 10) (add tig 87) d)

Examples
--------

    > `@t`~(x ne 7)
    '7'
    > `@t`~(x ne 14)
    'e'

------------------------------------------------------------------------

### `++v`

Render base-32

Renders a base-32 digit as an atom of an ASCII byte value.

Accepts
-------

Produces
--------

Source
------

      ++  v  ?:((gte tig 10) (add tig 87) d)

Examples
--------

    > `@t`~(v ne 7)
    '7'
    > `@t`~(v ne 14)
    'e'
    > `@t`~(v ne 25)
    'p'

------------------------------------------------------------------------

### `++w`

Render base-64

Renders a base-64 digit as an atom of an ASCII byte value.

Accepts
-------

Produces
--------

`tig` is an `atom`.

Source
------

      ++  w  ?:(=(tig 63) '~' ?:(=(tig 62) '-' ?:((gte tig 36) (add tig 29) x)))
      --
    ::

Examples
--------

    > `@t`~(w ne 7)
    '7'
    > `@t`~(w ne 14)
    'e'
    > `@t`~(w ne 25)
    'p'
    > `@t`~(w ne 52)
    'Q'
    > `@t`~(w ne 61)
    'Z'
    > `@t`~(w ne 63)
    '~'
    > `@t`~(w ne 62)
    '-'



***
