---
navhome: /docs/
---


# 3g: molds and mold builders
### `++coin`

Noun literal syntax cases

Noun literal syntax cases: atoms, jammed nouns, and nestable tuples.
Parsed and printed using `++so` and `++co` cores.

Source
------

    ++  coin  $%  {$$ p/dime}                               ::
                  {$blob p/*}                               ::
                  {$many p/(list coin)}                     ::
              ==                                            ::

Examples
--------

    > `coin`(need (slay '~s1'))
    [%$ p=[p=~.dr q=18.446.744.073.709.551.616]]
    > `coin`(need (slay '0x2b59'))
    [%$ p=[p=~.ux q=11.097]]

    > ~(rend co [%many ~[[%$ %ud 1] [%$ %tas 'a'] [%$ %s -2]]])
    "._1_a_-2__"
    > ._1_a_-2__
    [1 %a -2]

    > `@uv`(jam [3 4])
    0v2cd1
    > (slay '~02cd1')
    [~ [%blob p=[3 4]]]
    > ~02cd1
    [3 4]



***
### `++dime`

Odor-atom pair

Used in `++coin`. Convenience methods `++scot` and `++scow` (in
Section 2eL) print dimes as `++cord` and `++tape`, respectively.
`++slat`, `++slav`, and `++slaw` are used to parse atoms of
specific odors.

Source
------

        ++  dime  {p/@ta q/@}                                  ::


Examples
--------

    > +>:(slay '0x123')
    p=[p=~.ux q=291]



***
### `++edge`

Parsing location metadata

Optional result `p` and parsing continuation `q`.

Source
------

            ++  hair  {p/@ud q/@ud}                                 ::  parsing trace


Examples
--------

See also: Section 2eD, `++rule`

    > *edge
    [p=[p=0 q=0] q=~]
    > (tall:vast [1 1] "a b")
    [p=[p=1 q=2] q=[~ [p=[%cnzz p=~[%a]] q=[p=[p=1 q=2] q=" b"]]]]



***
### `++hair`

Parsing line and column

A pair of two [`@ud`]() used in parsing indicating line and column number.

Source
------

            ++  hair  {p/@ud q/@ud}                                 ::  parsing trace


Examples
--------

    > *hair
    [p=0 q=0]

    > `hair`[1 1] :: parsing starts at [1 1] as a convention.
    [p=1 q=1]
    > ((plus ace) [1 1] "   --")
    [p=[p=1 q=4] q=[~ u=[p=[~~. "  "] q=[p=[p=1 q=4] q="--"]]]]
    > `hair`p:((plus ace) [1 1] "   --")
    [p=1 q=4]



***
### `++like`

Mold generator for an edge

`++like` generates an `++edge` with a parsed result set to a specific type.

Source
------

    ++  like  |*  a/$-(* *)                                 ::  generic edge
              |=  b/_`*`[(hair) ~]                          ::
              :-  p=(hair -.b)                              ::
              ^=  q                                         ::
              ?@  +.b  ~                                    ::
              :-  ~                                         ::
              u=[p=(a +>-.b) q=[p=(hair -.b) q=(tape +.b)]] ::


Examples
--------
    > *(like char)
    [p=[p=0 q=0] q=~]

    > (ace [1 1] " a")
    [p=[p=1 q=2] q=[~ [p=~~. q=[p=[p=1 q=2] q="a"]]]]
    > `(like char)`(ace [1 1] " a")
    [p=[p=1 q=2] q=[~ [p=~~. q=[p=[p=1 q=2] q="a"]]]]
    > `(like ,@)`(ace [1 1] " a")
    [p=[p=1 q=2] q=[~ [p=32 q=[p=[p=1 q=2] q="a"]]]]



***
### `++nail`

Location, remainder of parsed text

Indicates parsing position `p`, and remaining text to be parsed `q`.

Source
------

            ++  nail  {p/hair q/tape}                               ::  parsing input


Examples
--------

    > +<:;~(plug cab cab)
    c=tub=[p=[p=0 q=0] q=""]
    > :: tub is a ++nail



***
### `++path`

Filesystem path

A `++path` is a list of `++span`s aka `@ta`. Used in
`%clay` and `%eyre` extensively.

Source
------

            ++  path  (list knot)                                   ::  filesys location


Examples
--------

    > `path`"abc"
    /a/b/c



***
### `++pint`

Parsing range

Mostly used for stacktraces. A `++pint` is a pair of
`++hair`, indicating from `p` to `q`.

Source
------

            ++  pint  {p/{p/@ q/@} q/{p/@ q/@}}                     ::  line+column range


Examples
--------

    > !:(!!)
    ! /~zod/try/~2014.9.20..01.22.04..52e3/:<[1 4].[1 6]>
    > :: !! always produces a crash
    > `pint`[[1 4] [1 6]]
    [p=[p=1 q=4] q=[p=1 q=6]]



***
### `++rule`

Parsing rule

`++rule` is an empty parsing rule, but it is used to check
that parsing rules match this with `_`.


Source
------

            ++  rule  _|=(nail *edge)                               ::  parsing rule


Examples
--------

    > *rule
    [p=[p=0 q=0] q=[~ [p=0 q=[p=[p=0 q=0] q=""]]]]

    > ^+(rule [|=(a=nail [p.a ~])]:|6)
    <1.dww [tub=[p=[p=@ud q=@ud] q=""] <101.jzo 1.ypj %164>]>
    > (^+(rule [|=(a=nail [p.a ~ u=['a' a]])]:|6) [1 1] "hi")
    [p=[p=1 q=1] q=[~ [p=97 q=[p=[p=1 q=1] q="hi"]]]]
    > ([|=(a=nail [p.a ~ u=['a' a]])]:|6 [1 1] "hi")
    [[p=1 q=1] ~ u=['a' p=[p=1 q=1] q="hi"]]



***
### `++spot`

Stack trace line

A `++spot` is what we print after crashing.

Source
------

            ++  spot  {p/path q/pint}                               ::  range in file


Examples
--------

    > :into /=main=/bin/fail/hoon '!:  !!'
    + /~zod/main/359/bin/fail/hoon
    > :fail
    ! /~zod/main/~2014.9.22..18.40.56..ef04/bin/fail/:<[1 5].[1 7]>
    ! exit



***
### `++toon`

Nock computation result

Either success (`%0`), a block with list of requests blocked on (`%1`), or
failure with stack trace (`%2`).

Source
------

            ++  toon  $%  {$0 p/*}                                  ::  success
                          {$1 p/(list)}                             ::  blocks
                          {$2 p/(list tank)}                        ::  stack trace
                                                  ==                                            ::


Examples
--------
    > (mock [[20 21] 0 3] $~)
    [%0 p=21]
    > (mock [[0] !=(.^(cy//=main/1))] ,~)
    [%1 p=~[[31.075 1.685.027.454 1.852.399.981 49 0]]]
    > (path [31.075 1.685.027.454 1.852.399.981 49 0])
    /cy/~zod/main/1

    > (mock [[1 2] !=(!:(+(.)))] ,~)
    [%2 p=~[[%leaf p="/~zod/try/~2014.9.23..18.34.32..d3c5/:<[1 20].[1 24]>"]]]



***
### `++wonk`

XX Not a model?

Pull result out of a `++edge`, or crash if there's no result.

Source
------

        ++  wonk  |*(veq=edge ?~(q.veq !! p.u.q.veq))           ::

Examples
--------

See also: [`++edge`]()

    > (wide:vast [1 1] "(add 2 2)")
    [ p=[p=1 q=10]
        q
      [ ~
        [ p=[%cnhp p=[%cnzz p=~[%add]] q=~[[%dtzy p=%ud q=2] [%dtzy p=%ud q=2]]]
          q=[p=[p=1 q=10] q=""]
        ]
      ]
    ]
    > (wonk (wide:vast [1 1] "(add 2 2)"))
    [%cnhp p=[%cnzz p=~[%add]] q=~[[%dtzy p=%ud q=2] [%dtzy p=%ud q=2]]]



***
